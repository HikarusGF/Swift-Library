/*
                        .-----------------------------------------------------------------------------.
                       /  .-.                                                                      .-.  \
                      |  /   \    Hikarus Guijarro-Fayard - iOS developer specialized in Swift    /   \  |
                      | |\_.  |                     http://ikiteruningen.net                     |    /| |
                      |\|  | /|                    https://github.com/HikarusG                   |\  | |/|
                      | `---' |                                                                  | `---' |
                      |       |------------------------------------------------------------------|       |
                      \       |                                                                  |       /
                       \     /                                                                    \     /
                        `---'                                                                      `---'
*/

class HKDataï¼‹ { // Functions to read and write with NSUserDefaults with implicit data-types to avoid having to cast --------------------------------------------------
   
   static let persistentStorageğŸ… = NSUserDefaults.standardUserDefaults()
   
   class func writePersistentï¹–(key$ key$: String, objectï¹–: AnyObject) { persistentStorageğŸ….setObject(objectï¹–, forKey: key$) }
   class func writePersistentâ“‘(key$ key$: String, booleanâ“‘: Bool) { persistentStorageğŸ….setBool(booleanâ“‘, forKey: key$) }
   class func writePersistentï¼ƒi(key$ key$: String, numberï¼ƒ: Int) { persistentStorageğŸ….setInteger(numberï¼ƒ, forKey: key$) }
   class func writePersistentï¼ƒf(key$ key$: String, numberï¼ƒ: Float) { persistentStorageğŸ….setFloat(numberï¼ƒ, forKey: key$) }
   class func writePersistentï¼ƒd(key$ key$: String, numberï¼ƒ: Double) { persistentStorageğŸ….setDouble(numberï¼ƒ, forKey: key$) }
   class func writePersistentğŸ…¤(key$ key$: String, URLğŸ…¤: NSURL) { persistentStorageğŸ….setURL(URLğŸ…¤, forKey: key$) }

   class func readPersistentï¹–(key$ key$: String) -> AnyObject? { return persistentStorageğŸ….objectForKey(key$) } // will need casting
   class func readPersistentâ“‘(key$ key$: String) -> Bool? { return persistentStorageğŸ….boolForKey(key$) }
   class func readPersistentï¹–ğŸ…(key$ key$: String) -> [AnyObject]? { return persistentStorageğŸ….arrayForKey(key$) as [AnyObject]?}
   class func readPersistentğŸ…(key$ key$: String) -> Dictionary<String,AnyObject>? { return persistentStorageğŸ….dictionaryForKey(key$) as Dictionary<String,AnyObject>? }
   class func readPersistent$(key$ key$: String) -> String? { return persistentStorageğŸ….stringForKey(key$) }
   class func readPersistent$ğŸ…(key$ key$: String) -> [String]? { return persistentStorageğŸ….stringArrayForKey(key$) }
   class func readPersistentï¼ƒi(key$ key$: String) -> Int? { return persistentStorageğŸ….integerForKey(key$) }
   class func readPersistentï¼ƒf(key$ key$: String) -> Float? { return persistentStorageğŸ….floatForKey(key$) }
   class func readPersistentï¼ƒd(key$ key$: String) -> Double? { return persistentStorageğŸ….doubleForKey(key$) }
   class func readPersistentÃŸ(key$ key$: String) -> NSData? { return persistentStorageğŸ….dataForKey(key$) }
   class func readPersistentğŸ…¤(key$ key$: String) -> NSURL? { return persistentStorageğŸ….URLForKey(key$) }
   
   class func deletePersistent(key$ Key$: String) { persistentStorageğŸ….removeObjectForKey(Key$) }
}


// CORE DATA related extensions ----------------------------------------------------------------------------------------------------------------------------------------

// singleton that returns the application delegate
let appDelegateğŸ…: AppDelegate = UIApplication.sharedApplication().delegate as! AppDelegate // Default appDelegate. We use it to connect to the data engine

// singleton that returns the AppDelegate's managedObjectContext
let coreDataMOCğŸ…: NSManagedObjectContext = appDelegateğŸ….managedObjectContext // handle to the DB

extension NSManagedObjectContext { // methods to fetch, create and delete objects from an entity -----------------------------------------------------------------------
   
   // used internally by the other funcions
   private func commitChangesâ“‘() -> Bool {
      var outputâ“‘ = true
      do { try  self.save() } catch { outputâ“‘ = false; print("\n* * * Error saving object! * * *\n") }
      return outputâ“‘
   }
   
   func createObjectInEntityğŸ…(entity$: String, assignmentsÆ’: (managedObjectğŸ…: NSManagedObject) -> (), completionÆ’: (() -> ())? = nil) -> NSManagedObject {
      let MOğŸ… = NSEntityDescription.insertNewObjectForEntityForName(entity$, inManagedObjectContext: self)
      assignmentsÆ’(managedObjectğŸ…: MOğŸ…)
      self.commitChangesâ“‘()
      completionÆ’?()
      return MOğŸ…
   }           /* the assignmentsÆ’() closure is where the new object's attributes are assigned from the calling code, then commitChangesâ“‘ is automatically infoked
               EXAMPLE:
                  let newContactMOğŸ… = coreDataMOCğŸ….createObjectInEntityğŸ…("Users", assignmentsÆ’: { userMOğŸ… in
                     userMOğŸ….setValue(userğŸ….phoneNumber$, forKey: "phoneNumber")
                     userMOğŸ….setValue(userğŸ….genderâ“‘, forKey: "gender")
                     userMOğŸ….setValue(userğŸ….firstName$!, forKey: "firstName")
                     userMOğŸ….setValue(userğŸ….lastName$!, forKey: "lastName")
                     userMOğŸ….setValue(userğŸ….picturesğŸ…ğŸ…[0]?.toJPGData(), forKey: "picture0")
                  })
            */
   
   
   func deleteObjectâ“‘(objectMOğŸ…: NSManagedObject) -> Bool {
      var outputâ“‘ = true
      self.deleteObject(objectMOğŸ…)
      do { try self.save() } catch { outputâ“‘ = false; print("Error deleting object!") }
      return outputâ“‘
   }
   
   func fetchEntityObjects(entityName$: String, predicateğŸ…: NSPredicate? = nil) -> [NSManagedObject]? {
      var fetchResultAOğŸ…: [AnyObject]?
      var entityMOğŸ… = [NSManagedObject]()
      let fetchRequestğŸ… = NSFetchRequest(entityName: entityName$); fetchRequestğŸ….returnsObjectsAsFaults = false
      if predicateğŸ….isNotNilâ“‘() { fetchRequestğŸ….predicate = predicateğŸ… }
      do { fetchResultAOğŸ… = try self.executeFetchRequest(fetchRequestğŸ…)
         if fetchResultAOğŸ…?.count > 0 { for recordMOğŸ… in fetchResultAOğŸ…! as! [NSManagedObject] { entityMOğŸ….append(recordMOğŸ…) } } // for edit: recordMOğŸ….setValue(<WhatEver>, forKey: fieldName$)
      } catch { print("Fetch Error: ãƒ‡ãƒ¼ã‚¿ãƒ™ã‚¹ã¨æ¥ç¶šãŒå¤±æ•—ã—ã¾ã£ãŸï¼") }
      return entityMOğŸ….count > 0 ? entityMOğŸ… : nil
      // if fields are altered once there are records already, we get a nasty error: "The model used to open the stroe is incompatible with the one used to create the store"
      // we must delete the app from the terminal to delete data model, then perform a project clean (â¬†ï¸âŒ˜K), then restart
      // PREDICATE EXAMPLE: let predicateğŸ… = NSPredicate(format: "eventType = %@ AND eventID = %@", eventListItemğŸ….eventTypeï¼ƒ!, eventListItemğŸ….eventID$!) // string has ''
   }
   
}

extension NSManagedObject { // attribute-access functions with implicit data-type to avoid having to cast ------------------------------------------------------------------------------------
   
   func valueForAttributeâ“‘(attributeName$: String) -> Bool?  { return self.valueForKey(attributeName$) as? Bool } // valueForKey returns an NSManagedObject so it must be cast into the desired type
   func valueForAttribute$(attributeName$: String) -> String?  { return self.valueForKey(attributeName$) as? String }
   func valueForAttributeï¼ƒi(attributeName$: String) -> Int?  { return self.valueForKey(attributeName$) as? Int }
   func valueForAttributeï¼ƒf(attributeName$: String) -> Float?  { return self.valueForKey(attributeName$) as? Float }
   func valueForAttributeï¼ƒd(attributeName$: String) -> Double?  { return self.valueForKey(attributeName$) as? Double }
   func valueForAttributeÃŸ(attributeName$: String) -> UIImage?  { if let imageÃŸ = self.valueForKey(attributeName$) as? NSData { return UIImage(data: imageÃŸ) } else { return nil } }
   func valueForAttributeãŠ(attributeName$: String) -> NSDate?  { return self.valueForKey(attributeName$) as? NSDate }
   
}

/* VARIABLE-TYPE SUFFIX CRITERION ----------------------------------------------------------------------------------------------------------------------------------------------------------

I've built a custom keyboard layout to include these suffix I find very useful in my code
Some characters like { ï¼ƒ ï¼‹ ï¹™ï¹š ï¹– } have resemblance to the standard pound, plus, parenthesis, question mark, but are really alternate ASCII characters that can perfectly be used in Swift code

you can of course remove them from the code :)

   Boolean              â“‘
   String               $
   number               ï¼ƒ
   Int                  ï¼ƒi
   Float                ï¼ƒf
   Double               ï¼ƒd
   CGFloat              â“–
   CGPoint              â“–Â²    2 dimensional CGFloats
   CGRect               â“–â´    4 dimensional CGFloats
   Binary/Data          ÃŸ     For NSData, and images or videos in CoreData
   Core Image           â“˜
   NSDate               ãŠ
   Object               ğŸ…
   Tuple                ğŸ…£
   Array                ğŸ…
   Set                  ...     ? not sure about this one...
   Dictionary           ğŸ…“
   Enumeration          ğŸ…”
   Structure            ğŸ…¢
   Library Class        ï¼‹     (suffix)
   Additive parameter   ï¼‹     (prefix)
   Complex Structure    ï¹™ï¹š
   Undetermined         ï¹–     for Undetermined types: Optional or AnyObject
   Implicitly unwrapped ï¹—
   Protocol             â“…
   Function             Æ’
   Pointer              â“Ÿâƒ—
   PhotoAsset           â“
   Collection           ğŸ…’
   URL                  ğŸ…¤
   
   Example: an array of dictionaries with a string key which value is a tuple of an enum and a number
   myVariableï¼ƒğŸ…”ğŸ…£$ğŸ…“ğŸ…
   
*/
