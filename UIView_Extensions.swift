/*
                             .-----------------------------------------------------------------------------.
                           /  .-.                                                                      .-.  \
                          |  /   \    Hikarus Guijarro-Fayard - iOS developer specialized in Swift    /   \  |
                          | |\_.  |                     http://ikiteruningen.net                     |    /| |
                          |\|  | /|                 https://github.com/ikiteruningen                 |\  | |/|
                          | `---' |                                                                  | `---' |
                          \       |------------------------------------------------------------------|       /
                           \     /                                                                    \     /
                            `---'                                                                      `---'
*/


extension UIView {
   
   // returns the main window
   var rootView: UIView { return self.window! }
   // returns an view's absolute coordinates in its superview's reference
   var absoluteOrigin‚ìñ¬≤: CGPoint { return self.superview!.convertPoint(self.frame.origin, toView: self.window) }
   
   // these functions are for nomenclature purposes and code clarity
   var visible‚ìë: Bool { get { return !self.hidden } set { self.hidden = !newValue } }
   var transparent‚ìë: Bool { return self.alpha == 0 }
   var opacity‚ìñ: CGFloat { get { return self.alpha } set { self.alpha = newValue } }
   var opaque‚ìë: Bool { return self.alpha != 0 }
   func transparent() { self.alpha = 0 }
   func opaque() { self.alpha = 1 }
   
   // returns the application's firstResponder is applied to the root view or window
   var activeControlüÖû: UIResponder? { return self.findActiveControlüÖû() }
   private func findActiveControlüÖû() -> UIResponder? {
      if self.isFirstResponder() { return self }
      for subView in self.subviews { if let responder = subView.findActiveControlüÖû() { return responder } }
      return nil
   }
   
   /*
   This function takes parameters to set a view's frame. Ommited parameter will keep their value
   Boolean "additive parameters" indicate whether the value should replace the current or be added to it
   I've included this function as an extension of UIView as well with the name setFrame()
   */
   func setFrame(x‚ìñ x‚ìñ: CGFloat? = nil, ÔºãX‚ìë: Bool = false, y‚ìñ: CGFloat? = nil, ÔºãY‚ìë: Bool = false, width‚ìñ: CGFloat? = nil, ÔºãW‚ìë: Bool = false, height‚ìñ: CGFloat? = nil, ÔºãH‚ìë: Bool = false) {
      var _x‚ìñ: CGFloat, _y‚ìñ: CGFloat, _width‚ìñ : CGFloat, _height‚ìñ: CGFloat
      _x‚ìñ = x‚ìñ.isNil‚ìë() ? self.frame.origin.x : ( ÔºãX‚ìë ? self.frame.origin.x + x‚ìñ! : x‚ìñ! )
      _y‚ìñ = y‚ìñ.isNil‚ìë() ? self.frame.origin.y : ( ÔºãY‚ìë ? self.frame.origin.y + y‚ìñ! : y‚ìñ! )
      _width‚ìñ = width‚ìñ.isNil‚ìë() ? self.frame.width : ( ÔºãW‚ìë ? self.frame.width + width‚ìñ! : width‚ìñ! )
      _height‚ìñ = height‚ìñ.isNil‚ìë() ? self.frame.height : ( ÔºãH‚ìë ? self.frame.height + height‚ìñ! : height‚ìñ! )
      self.frame = CGRectMake(_x‚ìñ, _y‚ìñ, _width‚ìñ, _height‚ìñ)
   }
   
   // centers the view with respect to an object's frame's center, independently of the relative size of both objects
   func centerInObjectFrame(objectÔπñ objectÔπñ: AnyObject) {
      if let castViewüÖû = objectÔπñ as? UIView {
         let containerFrame‚ìñ‚Å¥ = castViewüÖû.frame
         let W‚ìñ = containerFrame‚ìñ‚Å¥.width, H‚ìñ = containerFrame‚ìñ‚Å¥.height
         var w‚ìñ = self.frame.width, h‚ìñ = self.frame.height
         if w‚ìñ > W‚ìñ || h‚ìñ > W‚ìñ {
            let wExcess‚ìñ = w‚ìñ - W‚ìñ, hExcess‚ìñ = h‚ìñ - W‚ìñ
            if wExcess‚ìñ > hExcess‚ìñ {
               let scaleFactor‚ìñ = w‚ìñ / W‚ìñ
               w‚ìñ = W‚ìñ
               h‚ìñ = h‚ìñ / scaleFactor‚ìñ
            } else {
               let scaleFactor‚ìñ = h‚ìñ / H‚ìñ
               h‚ìñ = H‚ìñ
               w‚ìñ = w‚ìñ / scaleFactor‚ìñ
            }
         }
         self.frame = CGRect(x: (W‚ìñ - w‚ìñ) / 2, y: (H‚ìñ - h‚ìñ) / 2, width: w‚ìñ, height: h‚ìñ)
      }
   }
   
   // centers the view with respect to an object's bounds
   func centerAroundObjectBounds(objectÔπñ objectÔπñ: AnyObject) {
      if let castViewüÖû = objectÔπñ as? UIView {
         let containedBounds‚ìñ‚Å¥ = castViewüÖû.bounds
         let w‚ìñ = containedBounds‚ìñ‚Å¥.width, h‚ìñ = containedBounds‚ìñ‚Å¥.height
         let W‚ìñ = self.frame.width, H‚ìñ = self.frame.height
         if W‚ìñ < w‚ìñ || H‚ìñ < h‚ìñ { return }
         self.frame = CGRect(x: -(W‚ìñ - w‚ìñ) / 2, y: -(H‚ìñ - h‚ìñ) / 2, width: W‚ìñ, height: H‚ìñ)
      }
   }
   
   func dismissKeyboard() { self.endEditing(true) }
   
   // next 3 functions take a SNAPSHOT of a view and its subviews and return a UIImage, UIImageView or UIView respectively
   // very useful for certain animations and effects
   func rasterizeToImage() -> UIImage {
      UIGraphicsBeginImageContextWithOptions(self.bounds.size, false, 0.0)
      self.layer.renderInContext(UIGraphicsGetCurrentContext()!) // this like and the next are equivalent
      //      self.drawViewHierarchyInRect(self.bounds, afterScreenUpdates: YES)  // this like and the previous are equivalent
      let snapshot = UIGraphicsGetImageFromCurrentImageContext()
      UIGraphicsEndImageContext()
      return snapshot
   }
   func rasterizeToImageView() -> UIImageView { return UIImageView(image: self.rasterizeToImage()) }
   func rasterizeToView() -> UIView { return self.snapshotViewAfterScreenUpdates(true) }
   
   // brings subviews to front in the order specified by the array passed
   func bringSubviewsToFront(subviews: [UIView]) { for subview in subviews { self.bringSubviewToFront(subview) } }
   
   // slide the view up to make room for the screen keyboard when the firstResponder is a UI text control that would be hidden by the keyboard
   // if the control above the keyboard height the view doesn't slide up
   func slideUpForKeyboard(keyboardNotification notification: NSNotification, durationÔºÉ: NSTimeInterval = 0.4) {
      var keyboardHeight‚ìñ = CGFloat()
      if let keyboardSize = (notification.userInfo?[UIKeyboardFrameBeginUserInfoKey] as? NSValue)?.CGRectValue() {
         keyboardHeight‚ìñ = keyboardSize.height
         if let responder = self.activeControlüÖû as? UIView {
            if (responder.className$ == "UITextField") || (responder.className$ == "UITextView") || (responder.className$ == "HikarianUITextView") || (responder.className$ == "HikarianUITextView") {
               if responder.absoluteOrigin‚ìñ¬≤.y + responder.frame.height >= (responder.window!.frame.height - keyboardHeight‚ìñ) {
                  UIView.animateWithDuration(durationÔºÉ, delay: 0, options: .CurveEaseOut, animations: { self.frame =  CGRect(x: self.frame.origin.x, y: self.frame.origin.y - keyboardHeight‚ìñ, width: self.frame.width, height: self.frame.height) }, completion: nil)
                  keyboardIsUp‚ìë = true
               }
            }
         }
      }
   }
   
   // performs an animation where the view moves vertical or horizontally by specified amounts
   func slide(vertical vertical‚ìñ: CGFloat = 0, horizontal‚ìñ: CGFloat = 0, duration: NSTimeInterval = 0.4) { // slides a UIView by the provided offsets and with the provided duration
      UIView.animateWithDuration(duration, delay: 0, options: .CurveEaseOut, animations: { self.setFrame(x‚ìñ: self.frame.origin.x + horizontal‚ìñ, y‚ìñ: self.frame.origin.y + vertical‚ìñ) }, completion: nil)
   }
   
   // slide a view's subviewd up to make room for the screen keyboard when the firstResponder is a UI text control that would be hidden by the keyboard
   // if the control above the keyboard height the view doesn't slide up
   func slideSubViewsUpForKeyboard(keyboardNotification notification: NSNotification, subViews: [UIView], durationÔºÉ: NSTimeInterval = 0.4) { // this is the equivalent of theUIView extension, but slides up an array of UIView inheritants
      if keyboardIsUp‚ìë { return }
      var keyboardHeight‚ìñ = CGFloat()
      if let keyboardSize = (notification.userInfo?[UIKeyboardFrameBeginUserInfoKey] as? NSValue)?.CGRectValue() {
         keyboardHeight‚ìñ = keyboardSize.height
         if let responder = self.activeControlüÖû as? UIView {
            if (responder.className$ == "UITextField") || (responder.className$ == "UITextView") || (responder.className$ == "HikarianUITextField") || (responder.className$ == "HikarianUITextView") {
               if responder.absoluteOrigin‚ìñ¬≤.y + responder.frame.height >= (responder.window!.frame.height - keyboardHeight‚ìñ) {
                  UIView.animateWithDuration(durationÔºÉ, delay: 0, options: .CurveEaseOut, animations: { for subView in subViews { subView.setFrame(y‚ìñ: subView.frame.origin.y - keyboardHeight‚ìñ) } }, completion: nil)
                  keyboardIsUp‚ìë = true
               }
            }
         }
      }
   }
   // slide a view's subviews to make room for the screen keyboard
   func slideSubViews(forKeyboard‚ìë forKeyboard‚ìë: Bool = false,  subViews: [UIView], vertical‚ìñ: CGFloat = 0, horizontal‚ìñ: CGFloat = 0, durationÔºÉ: NSTimeInterval = 0.4) {
      if forKeyboard‚ìë && !keyboardIsUp‚ìë { return }
      for subView in subViews { UIView.animateWithDuration(durationÔºÉ, delay: 0, options: .CurveEaseOut, animations: { subView.setFrame(y‚ìñ: subView.frame.origin.y + keyboardHeight‚ìñ) }, completion: nil); if forKeyboard‚ìë { keyboardIsUp‚ìë = false } }
   }
   
   // view fades in to alpha 1
   func fadeIn(duration duration: NSTimeInterval = 1.0, delay: NSTimeInterval = 0.0, completion: ((Bool) -> Void) = { (finished‚ìë: Bool) -> Void in }) {
      UIView.animateWithDuration(duration, delay: delay, options: UIViewAnimationOptions.CurveEaseIn, animations: { self.alpha = 1.0 }, completion: completion)
   }
   // view fades out to alpha 0
   func fadeOut(duration durationÔºÉ: NSTimeInterval = 1.0, delayÔºÉ: NSTimeInterval = 0.0, completion: (Bool) -> Void = { (finished‚ìë: Bool) -> Void in }) {
      UIView.animateWithDuration(durationÔºÉ, delay: delayÔºÉ, options: UIViewAnimationOptions.CurveEaseIn, animations: { self.alpha = 0.0 }, completion: completion)
   }
   // view blinks. Useful to make certain UI components blink and draw the user attention
   // uses the 2-Phase animation in the file UIView_Animations.swift
   func blink(blinksÔºÉ: Int) { HKUIÔºã.animation2ùúô(iterationsÔºÉ: blinksÔºÉ, ùúô1DurationÔºÉ: 0.02,  ùúô1∆í: { self.alpha = 0 }, ùúô2∆í: { self.alpha = 1 }) }
   
   // sets a view's border appearance
   func setBorderStyle(width‚ìñ width‚ìñ: CGFloat, colorüÖû: UIColor, cornerRadius‚ìñ: CGFloat) {
      self.layer.borderWidth = width‚ìñ
      self.layer.borderColor = colorüÖû.CGColor
      self.layer.cornerRadius = cornerRadius‚ìñ
      self.layer.masksToBounds = true
   }
}

/* VARIABLE-TYPE SUFFIX CRITERION ----------------------------------------------------------------------------------------

I've built a custom keyboard layout to include these suffix I find very useful in my code
Some characters like { ÔºÉ Ôºã ÔπôÔπö Ôπñ Ôπ´} have resemblance to the standard pound, plus, parenthesis, question mark, At-Sign...
but are really alternate ASCII characters that can perfectly be used in Swift code

you can of course remove them from the code :)

Boolean              ‚ìë
String               $
number               ÔºÉ
Int                  ÔºÉi
Float                ÔºÉf
Double               ÔºÉd
CGFloat              ‚ìñ
CGPoint              ‚ìñ¬≤    2 dimensional CGFloats
CGRect               ‚ìñ‚Å¥    4 dimensional CGFloats
Binary/Data          √ü     For NSData, and images or videos in CoreData
Core Image           ‚ìò
NSDate               „äê
Object               üÖû
Tuple                üÖ£
Array                üÖê
Set                  ...     ? not sure about this one...
Dictionary           üÖì
Enumeration          üÖî
Structure            üÖ¢
Library Class        Ôºã     (suffix)
Additive parameter   Ôºã     (prefix)
Complex Structure    ÔπôÔπö
Undetermined         Ôπñ     for Undetermined types: Optional or AnyObject
Implicitly unwrapped Ôπó
Protocol             ‚ìÖ
Function             ∆í
Pointer              ‚ìü‚Éó
PhotoAsset           ‚ìê
Collection           üÖí
URL                  üÖ§
IBOutlets            Ôπ´

Example: an array of dictionaries with a string key which value is a tuple of an enum and a number
myVariableÔºÉüÖîüÖ£$üÖìüÖê

----------------------------------------------------------------------------------------------------------------- */
